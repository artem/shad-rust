Вы данной задаче вам предлагается написать несколько функций для работы с итераторами:

* `count()` - создаёт итератор, который возвращает по порядку числа от 0 до `u64::MAX`. При вызове
`.next()` после того, как вернулся `u64::MAX`, можно паниковать.
* `cycle(into_iter)` - создаёт бесконечный итератор, который возвращает зацикленно последовательность
элементов, полученную из `into_iter`. Заметьте, что нижележащий итератор должен истощаться лениво,
а не сразу при вызове `cycle`. `Item` обязан быть `Clone`.
* `extract(into_iter, index)` - возвращает пару, первый элемент которой - `Option<Item>`, где `Item` -
элемент итератора под номером `index` (начиная с 0), если таковой есть. Второй элемент пары -
итератор, который должен возвращать элементы исходного итератора в той же последовательности,
но без извлечённого элемента. Заметьте, что исходный итератор должен быть истощён не более,
чем на `index + 1` элемент.
* `tee(into_iter)` - возвращает пару из двух независимых итераторов, каждый из которых возвращает
ровно ту же последовательность элементов, что исходный итератор. Исходный итератор должен при этом
истощаться лениво: из него всегда должно быть извлечено кол-во элементов, равное максимуму из
кол-ва извлечённых элементов у двух итераторов, которые `tee` вернул. `Item` обязан быть `Clone`.
* `group_by(into_iter, f)` - объединяет все идущие подряд элементы, для которых `f` возвращает
одинаковое значение, в группы. `group_by` возвращает итератор по парам, где первый элемент - это `f(item)`,
а второй элемент - это вектор из идущих подряд элементов, таких, что `f(item)` для каждого из этих
элементов равен первому элементу пары.

Советуем воспользоваться следующими функциями из std:
* [iter::repeat_with](https://doc.rust-lang.org/std/iter/fn.repeat_with.html)
* [iter::from_fn](https://doc.rust-lang.org/std/iter/fn.from_fn.html)
* [Iterator::chain](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain)