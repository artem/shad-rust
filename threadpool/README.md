В данной задаче вам предлагается написать простой thread pool.

## Интерфейс

* В конструктор thread pool принимает количество тредов, а также максимальный размер очереди тасок.
* Метод `.spawn()` принимает таску (функцию) и возвращает её handle. Если максимальный размер очереди
тасок не превышен, то `.spawn()` возвращает управление немедленно. Иначе `.spawn()` ждёт, пока
в очереди освободится место.
* Handle, который возвращается из `.spawn()`, имеет метод `.join()`, возвращающий `Result<T, JoinError>`.
Здесь `T` - тип значения, которое возвращает таска. `JoinError` возвращается в том случае, если
таска запаниковала.
* Метод `.shutdown()` тред пула дожидается, пока все текущиепотоки закончат свою работу, и завершает их.

## Реализация

* Мы не будем поддерживать скоупы в нашем thread pool, так что все таски должны быть `'static`.
* Чтобы остановить раскрутку стека в случае паники таски, делайте так:

	```rust
	use std::panic::{catch_unwind, AssertUnwindSafe};

	catch_unwind(AssertUnwindSafe(task))
	```

  На одном из следующих занятий мы поговорим подробнее про unwind safety. Пока вам достаточно знать,
  что паника не может сломать memory safety в safe Rust, но может неожиданно нарушить какие-то
  логические инварианты. `AssertUnwindSafe` соглашается на это.
* Для распределения тасок по потокам используйте `crossbeam::channel::bounded()`. Этот канал
является multiple producer, multiple consumer: у вас может быть много `Sender`'ов и много `Receiver`'ов,
при этом то, что отправляется с какого-то `Sender`, достанется ровно одному `Receiver`.
* Если вы знаете, что такое condition variables, у вас может возникнуть соблазн их использовать.
Хоть это и может быть капельку быстрее, это сильно усложнит код. Лучше стройте взаимодействие
между потоками на каналах.