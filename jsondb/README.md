В первом домашнем проекте вам предлагается написать базу данных, хранящую json-документы.

## 1. Язык запросов

Все запросы к нашей базе тоже являются json-документами. Это существенно упростит их парсинг.

База состоит из произвольного числа именованных коллекций. Коллекция, в свою очередь, состоит из документов.

### 1.1. Insert

Пример запроса на вставку документа `{"name": "Vasya"}` в коллекцию `persons`:

`{"collection": "persons", "insert": {"name": "Vasya"}}`

Также одним запросом можно вставить несколько документов:

`{"collection": "persons", "insert": [{"name": "Petya"}, {"name": "Bill"}]}`

### 1.2. Select

Следующий запрос вернёт все документы в коллекции `test_collection`:

`{"collection": "persons", "select": {}}`

А так можно запросить все документы, у которых `name = "Bill"`:

`{"collection": "persons", "select": {"name": "Bill"}}`

Select-выражением также можно задавать запросы вглубь документа:

`{"collection": "persons", "select": {"birthday": {"month": 4}}}`

Приведённый выше запрос вернёт все документы, у которых `birthday.month = 4`.

На пути документа можно задавать выражения в качестве условия фильтрации.
Например, следующий запрос вернёт все документы, у которых `birthday.year > 1995`:

`{"collection": "persons", "select": {"birthday": {"year": {"$gt": 1995}}}}`

Все выражения состоят из словаря, который имеет единственный ключ, начинающийся на `$`.
**Документам в БД запрещено содержать ключи, начинающиеся с `$`**
(должна произойти ошибка вставки).

Поддерживаются следующие выражения:
* `$lt`, `$gt`, `$eq` - меньше, больше и равно, соответственно. Для значений двух разных типов все предикаты возвращают `false`. Для двух значений одинаковых типов сравнение определено так:
  - Два `null` всегда равны между собой;
  - Два `bool` и два `int` сравниваются естественным образом;
  - Два `float` сравниваются в соответствии с [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754#Comparison_predicates);
  - Две `string` сравниваются лексикографически;
  - Два `list` сравниваются лексикографически рекурсивно.
  - Два `document` могут сравниваться только на равенство, но не на порядок. Сравнения `$lt` и `$gt` для `document` всегда возвращают `false`.
* `$in` - возвращает `true`, если значение в документе равно одному из указанных значений. Пример запроса:
`{"collection": "persons", "select": {"name": {"$in": ["Vasya", "Bill"]}}}`
* `$or`, `$and` - дизъюнкция и конъюнкция. Пример использования:
`{"collection": "persons", "select": {"$or": [{"name": "Vasya"}, {"age": 15}]}}`

Заметьте, что следующие два запроса имеют разный смысл:
1. `{"collection": "persons", "select": {"birthday": {"year": 2000}}}` - вернёт все документы, у которых `birthday.year = 2000`
2. `{"collection": "persons", "select": {"birthday": {"$eq": {"year": 2000}}}}` вернёт все документы, у которых `birthday = {"year": 2000}`.

Операторы `$or` и `$and` могут встречаться только на верхнем уровне запроса (до того, как в нём будут какие-то ключи в теле документа).

Если в запросе встречаются несколько ключей, то накладываемые ограничения объединяются. Например, следующий запрос вернёт все документы, у которых `name = "Vasya"` и `age = 20`:

`{"collection": "persons", "select": {"name": "Vasya", "age": 20}}`

Если запрос обращается к ключам, которых у данного документа нет, то считается, что этот ключ имеет значение `null`.

### 1.3. Show

Следующая команда возвращает список всех непустых коллекций:

`{"show": "collections"}`

## 2. Реализация

Вам необходимо реализовать структуру `Database` в файле `database.rs`. У этой структуры всего два метода: `Database::new()` возвращает новую пустую базу данных, а метод `.exec("...")` исполняет запрос и возвращает результат его исполнения.

Заметьте, что в публичном интерфейсе `Database` используются два внешних крейта:
* Тип [JsonValue](https://docs.rs/json/latest/json/enum.JsonValue.html) из библиотеки `json`. Подразумевается, что парсить запрос вы будете, пользуясь функцией [json::parse](https://docs.rs/json/latest/json/fn.parse.html).
* Тип [Result](https://docs.rs/anyhow/latest/anyhow/type.Result.html) из библиотеки anyhow. Это обычный `Result`, у которого ошибка - это [anyhow::Error](https://docs.rs/anyhow/latest/anyhow/struct.Error.html).

### 2.1. Структура кода

В заготовке решения есть несколько файлов, по которым вы можете распределять код. Задумка за каждым из них следующая:
* `ast.rs` - содержит структуры и енумы, описывающие запрос.
* `collection.rs` - содержит структуру `Collection`.
* `data.rs` - содержит структуры, описывающие поддерживаемые нашей базой значения. Вы можете не захотеть определять свои структуры, а работать напрямую с `json::JsonValue`, но это может быть неудобно.
* `database.rs` - содержит структуру `Database`.
* `util.rs` - содержит всё остальное, что логически не попадает в другие файлы.

### 2.2. Обработка ошибок

Для обработки ошибок используется библиотека anyhow. Не стесняйтесь пользоваться оператором `?`, методами [.context](https://docs.rs/anyhow/latest/anyhow/trait.Context.html#tymethod.context), [.with_context](https://docs.rs/anyhow/latest/anyhow/trait.Context.html#tymethod.with_context), макросами [bail!](https://docs.rs/anyhow/latest/anyhow/macro.bail.html) и [ensure!](https://docs.rs/anyhow/latest/anyhow/macro.ensure.html).

Старайтесь делать сообщения об ошибке как можно более понятными человеку. Тестов на конкретные тексты ошибок в задаче нет.
