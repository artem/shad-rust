В этой задаче вам предлагается реализовать парсер файлового формата `tar`.

## Описание формата

Tar - старый, странный, но простой формат. Его предназначение в том, чтобы объединять набор файлов в один файл.

Tar-архив начинается с заголовка. Заголовок имеет размер в 1 блок (в рамках задачи считайте размер блока равным 512 байт). Заголовок блока имеет следующий формат:
* Имя файла - 100 байт
* Флаги доступа - 8 байт
* User ID - 8 байт
* Group ID - 8 байт
* Размер данных - 12 байт
* Другие поля, неинтересные нам в рамках задачи

За блоком-заголовком следует N блоков с данными этого файла. Данных ровно столько, сколько указано в заголовке. После данных с границы следующего блока следует новый заголовок, и т.д. Конец файла маркируется двумя нулевыми блоками.

Формат записи полей заголовка:
* Имя файла - это произвольная нуль-терминированная последовательность байт.
* Флаги, UID, GID и размер представлены нуль-терминированными строками, содержащими в ASCII-кодироке число по основанию 8. Например, "0000100\0" означает 64. Не спрашивайте, почему. Никто не знает.

## Реализация

Реализуйте функцию `parse_tar` в файле `src/lib.rs`. Функция принимает слайс байт, представляющих собой лежащий в памяти tar-архив. Вам нужно его распарсить и вернуть `Vec<TarFile>`. Заметьте, что структура `TarFile` содержит поля `header.name` и `data`, в которых лежат подслайсы входного слайса.

Вам могут пригодиться следующие функции:
* [str::from_utf8](https://doc.rust-lang.org/stable/std/str/fn.from_utf8.html)
* [u32::from_str_radix](https://doc.rust-lang.org/stable/std/primitive.u32.html#method.from_str_radix)
* Чтобы найти позицию нулевого байта в слайсе: `slice.iter().position(|byte| *byte == 0)`
* Чтобы проверить, что все байты в слайсе нулевые: `slice.iter().all(|byte| *byte == 0)`

Если входные данные не соответствуют спефицикации формата tar - паникуйте.
