В данной задаче вам предлагается написать солвер пятнашек 3х3. Пример входа:

```
12.
453
786
```

Вывод:

```
---
123
45.
786
---
123
456
78.
```

## Реализация

Программа разбита на два файла:

* `main.rs` - читает вход, запускает алгоритм решения и выводит результат.
* `lib.rs` - содержит реализацию алгоритма, включая используемые структуры данных: `Tile` и `Board`.

Файл `main.rs` уже написан за вас, вам надо вписать недостающий код в `lib.rs`.

### Структура `Tile`

```rust
pub struct Tile(u8);
```

* Ключевое слово `pub` означает, что структура является частью публичного интерфейса модуля (мы поговорим подробнее про модули в одной из следующих лекций).
* `Tile(u8)` означает, что структура `Tile` содержит ровно одно анонимное приватное поле типа `u8`.
Изнутри структуры можно обращаться к этому полю как `self.0`.

Данная структура реализует распространённый в Rust паттерн newtype. Имея на руках `Tile`, мы можем быть
абсолютно уверены, что это валидный тайл: он либо имеет номер от 1 до 8, либо явяется пустым тайлом.
То, какое именно значение `u8` кодирует пустой тайл, скрыто как деталь реализации.

Внутри блока `impl Tile { /* ... */ }` содержатся методы структуры `Tile`. Они делятся на два типа:

* Статические методы:

```rust
pub fn new(maybe_value: Option<u8>) -> Self;
pub fn empty() -> Self;
```

Эти методы вызываются как `Tile::new(...)` и `Tile::empty()` и, в данном случае, оба возвращают новый экземпляр структуры `Tile`.

* Константные методы:

```rust
pub fn number(&self) -> Option<u8>;
pub fn is_empty(&self) -> bool;
```

Эти методы вызываются на конкретном экземпляре `Tile` как `tile.number()` и принимают константную
ссылку `&self`.

Как мы увидим далее, методы также бывают неконстантными: они принимают `&mut self`.

Контракт данных методов описан в docstring над ними. Реализуйте эти методы.

Советы:

* Заметьте, что метод `Tile::new` должен паниковать, если переданное значение не лежит на отрезке
от 1 до 8. Чтобы запаниковать, можно использовать один из следующих вариантов:

	* `panic!("invalid tile value: {}", value)` - безусловная паника;
	* `assert!(expr, "invalid tile value: {}", value)` - паника при условии, что `expr` ложно.

* Чтобы создать конкретный экземпляр Tile внутри `Tile::new`, используйте
выражение `Tile(0)` или `Self(0)`.
* Чтобы создать `Option<u8>`, используйте выражение `Some(0)` или `None`.

### Макрос `derive`

Можно заметить, что структура `Tile` не обладает некоторыми удобными свойствами `u8`. А именно:

* Тайл нельзя скопировать методом `let new_tile = old_tile;`
* Тайлы нельзя проверить на равенство как `tile_one == tile_two`
* Тайл нелья использовать как ключ в `HashSet`/`HashMap`
* Нельзя напечатать тайл в `println!`

Чтобы явно наделить структуру этими свойствами, надо поместить над её объявлением следующее заклинание:

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
```

`derive` является **процедурным макросом**: он принимает на вход объявление структуры и автоматически
генерирует реализации указанных в скобках **трейтов**. В последующих лекциях мы будем подробнее говорить
о том, что такое трейты и что такое процедурные макросы.

Derive указанных в скобках трейтов имеет следующие последствия для нашей структуры:

* `Clone` - добавляет структуре метод `.clone()`, который возвращает полную копию экземпляра.
* `Copy` - разрешает делать неявное копирование структуры как `let new_s = old_s;`. В следующей лекции
мы подробно поговорим про неявное копирование.
* `Debug` - генерирует debug-представление структуры для печати: `println!("{:?}", s)`.
* `PartialEq`, `Eq` - добавляют оператор равенства, являющийся отношением эквивалентности.
* `Hash` - генерирует реализацию хеширования для данного типа, позволяя использовать его как ключ
в `HashSet`/`HashMap`.

### Структура `Board`

`Board` содержит единственный атрибут: двумерный массив тайлов 3х3. Почему тогда предлагается завести
отдельную структуру, а не работать просто с двумерным массивом тайлов?

* Не всякий двумерный массив тайлов является валидным `Board`: каждый тайл должен встречаться на доске
ровно один раз. Имея переменную типа `Board`, мы можем быть уверены, что этот инвариант соблюдён.
* В `Board` удобно иметь сопутствующие методы, вроде `from_string` и `to_string`.
* Проще писать `Board`, чем `[[Tile; 3]; 3]`.

Реализиуйте методы `Board`, опираясь на их docstrings. Также добавьте к структуре `Board` указанный выше `derive`.

Советы:
* Вы можете преобразовать `[[Tile; 3]; 3]` в `HashSet<Tile>` следующим образом:

```rust
let set = tiles.iter().flatten().cloned().collect::<HashSet<_>>();
```

* Создать двумерный массив пустых тайлов:

```rust
let tiles = [[Tile::empty(); 3]; 3];
```

* Проитерироваться по первым 3 строкам (lines) строки (String) вместе с индексом:

```rust
for (i, line) in s.split('\n').take(3).enumerate() {
	// ...
}
```

* Проитерироваться по первым 3 символам строки вместе с индексом:

```rust
for (i, chr) in s.chars().take(3).enumerate() {
	// ...
}
```

* Сконвертировать `u8` от 0 до 9 в `char`: `(b'0' + n) as char`

### Функция `solve`

Опираясь на методы структуры `Board`, реализуйте обход в ширину всех конфигураций доски, достижимых
из данной стартовой конфигурации. Достижимыми считаются конфигурации, которые могут быть получены
из исходной доски переставлениями двух тайлов, Манхеттенское расстояние между которыми равно 1,
и один из этих тайлов должен быть пустым тайлом.

Как только обход достигает финальной конфигурации, он останавливается и возвращает путь от исходной
конфигурации до финальной (исходная конфигурация не включается). Финальной считается следующая конфигурация:

```
123
456
78.
```

Если входная конфигурация уже является финальной, функция `solve` возвращает пустой вектор.
Если финальная конфигурация недостижима из исходной, функция возвращает `None`.

Советы:
* В качестве очереди используйте [VecDeque](https://doc.rust-lang.org/std/collections/struct.VecDeque.html).
* Чтобы хранить предыдущую конфигурацию для каждой посещённой, используйте `HashMap<Board, Board>`.
* Цикл обхода можно красиво написать так:

```rust
while let Some(board) = queue.pop_front() {
    // Переменная `board` содержит элемент, который мы достали из очереди.
}
```

Здесь используйется pattern matching, о котором мы подробнее поговорим на следующей лекции.

* Может быть, вам пригодится метод [wrapping_sub](https://doc.rust-lang.org/std/primitive.usize.html#method.wrapping_sub), определённый для всех целочисленных типов.
* Возможно, вы захотите добавить в `Board` какие-то методы. Не сдерживайтесь :)

## Запуск

Чтобы запустить приложение руками, используйте команду:

```
cargo run --release
```

После этого введите конфигурацию в формате:

```
123
456
78.
```

## Тестирование

Для запуска тестов используйте команду:

```
make
```

В данной задаче юнит-тесты, так что вы можете запустить в дебагере любой из тестов в `tests/tests.rs`.
Используйте хинт `Run Test | Debug`, который VS Code отображает над каждым тестом.
