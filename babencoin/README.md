В этом проекте мы с вами напишем blockchain, основанный на простом алгоритме proof of work -
Babencoin (все права защищены, любое использование токена без согласия владельце запрещено).

## 1. Описание блокчейна

### 1.1. Формат блока

Блокчейн - это последовательность блоков. Пример блока нашего блокчейна:

```json
{
  "index": 1,
  "nonce": 27532,
  "reward": 1000,
  "issuer": "...",
  "timestamp": 1626003028,
  "max_hash": "...",
  "prev_hash": "...",
  "transactions": [
    {
      "amount": 500,
      "fee": 30,
      "comment": "hi",
      "sender": "...",
      "receiver": "...",
      "signature": "..."
    }
  ]
}
```

(полный блок, без сокращений, можно увидеть в `data/test_block.json`)

Значения полей:
* `index` - расстояние от данного блока до блока генезиса (нулевого блока, захардкоженного в блокчейн);
* `nonce` - произвольное число, не несущее смысла само по себе;
* `reward` - кол-во бабенкоинов, которое получает тот, кто намайнил этот блок;
* `issuer` - публичный RSA-ключ того, кто намайнил этот блок (он же получает `reward`);
* `timestamp` - таймстемп момента, когда этот блок создан;
* `max_hash` - максимально допустимое значение хеша, которым должен обладать этот блок (см. 1.3);
* `prev_hash` - хеш предыдущего блока;
* `transactions` - список транзакций данного блока. Поля транзакции:
  * `amount` - сколько бабенкоинов пересылается;
  * `fee` - сколько бабенкоинов достаётся майнеру блока;
  * `comment` - произвольный строковой комментарий;
  * `sender` - публичный RSA-ключ отправителя средств;
  * `receiver` - публичный RSA-ключ получателя средств;
  * `signature` - подпись транзакции приватным ключом отправителя.

При сериализации в json подписи, ключи и хеши представляются в кодировке base64.

Мы не будем приводить точную спецификацию того, как считается хеш блока и подпись, а также в каком
именно формате серализуется RSA-ключ. Считайте, что это определено реализацией в `src/data.rs`.

### 1.2. Протокол

Все узлы блокчейна образуют одноранговую (peer-to-peer) сеть - т.е. общение между узлами абсолютно
симметрично (в отличие, например, от клиент-серверных протоколов).

Узлы устанавливают друг с другом соединения по протоколу TCP. По установленному соединению узлы
обмениваются сообщениями в формате json. Каждые два последовательных сообщения разделены нулевым
байтом. Максимальный размер одного сообщения - 64 килобайта.

Бывает три разновидности сообщений:

1. Блок - отправитель сообщает получателю о том, что существует некоторый валидный с т.з.
отправителя блок. Формат:
```json
{
	"kind": "block",
	... // все атрибуты блока в том виде, как они представлены в 1.1.
}
```
2. Транзакция - отправитель сообщает получателю, что существует некоторая валидная с т.з.
отправителя транзакция, ещё не присутствующая ни в каком блоке. Формат:
```json
{
	"kind": "transaction",
	... // все атрибуты транзакции в том виде, как они представлены в 1.1.
}
```
3. Запрос блока - отправитель сообщает получателю, что желает получить блок, хеш которого равен
указанному хешу. Формат:
```json
{
	"kind": "request",
	"block_hash": "..."
}
```
Добросовестно реализованный узел при получении такого сообщения должен проверить, имеется ли у него
информация о таком блоке, и если да, отправить этот блок в ответ сообщением первого типа.

### 1.3. Майнинг

Любой участник сети может добавить в блокчейн новый блок на следующих условиях:

1. Этот блок должен иметь в качестве предка блок генезиса (родство определяется ссылками `prev_hash`);
2. Его `timestamp` должен быть больше, чем `timestamp` родительского блока;
3. `reward` не должен превышать 1000;
4. Все транзакции блока должны быть валидными:
  * Отправитель каждой транзакции должен иметь на счету достаточно бабенкоинов, чтобы оплатить
  `amount + fee`;
  * Транзакция должна иметь верную подпись отправителя.
5. Численное значение хеша блока не должно превышать значение `max_hash`.

Значение max_hash рассчитывается каждые 16 блоков следующим образом:

```
new_max_hash = old_max_hash * (avg_block_mining_time / target_block_mining_time)
```

Здесь:
* `old_max_hash` - значение max_hash на протяжении предыдущих 16 блоков;
* `avg_block_mining_time` - среднее время майнинга одного блока за последние 16 блоков;
* `target_block_mining_time` - 10 секунд.

Задача майнера - подобрать такой `nonce`, чтобы хеш блока не превосходил `max_hash` - тогда
полученный блок будет валидным, другие участники признают этот блок и майнер получит свою награду.

Добросовестно реализованный майнер должен майнить новый блок, `prev_hash` которого равен хешу
блока с максимальным `index` среди всех валидных блоков, которые данному майнеру известны. При
наличии нескольких таких блоков с одинаковым `index`, майнеру следует предпочитать тот блок,
который раньше всех стал известен данному майнеру.

## 2. Архитектура узла

Узел состоит из трёх сервисов, каждый из которых работает в отдельном тредпуле (tokio runtime),
общаясь с другими сервисами посредством каналов.

1. Peer service - управляет TCP-соединениями с другими узлами;
2. Gossip service - распространяет между узлами информацию о блоках и транзакциях;
3. Mining service - майнит новый блок.

Схема взаимосвязей между сервисами:

```
        TCP streams
             ▲
             │
             ▼
     ┌────────────────┐
     │                │
     │  Peer service  │
     │                │
     └─────┬──────────┘
           │   ▲
 PeerEvent │   │ PeerCommand
           ▼   │
     ┌─────────┴──────┐
     │                │
     │ Gossip service │
     │                │
     └─────┬──────────┘
           │   ▲
MiningInfo │   │ Block
           ▼   │
     ┌─────────┴──────┐
     │                │
     │ Mining service │
     │                │
     └────────────────┘
```


### 2.1. Peer service

Peer service генерирует события PeerEvent и реагирует на команды PeerCommand.

События всегда происходят в рамках какой-то сессии, где сессия означает TCP-соединение. Каждому
новому соединению назначается новый уникальный целочисленный идентификатор сессии.

События бывают трёх типов:
1. Создана новая сессия (к нам подсоединились, либо мы успешно установили соединение);
2. Пришло новое сообщение;
3. Сессия разорвана.

Команды, на которые реагирует peer service, бывают двух типов:
1. Послать какое-то сообщение в рамках конкретной сессии;
2. Разорвать сессию.

Конфиг peer service состоит из следующих параметров:
* `dial_addresses` - список адресов, с которыми сервис будет активно пытаться установить соединение;
* `dial_cooldown` - сколько времени подождать после неудачной попытки соединения или его разрыва
перед тем, как пытаться снова соединиться с адресом;
* `listen_address` - на каком адресе слушать входящие соединения.

### 2.2. Gossip service

Gossip service реагирует на события PeerEvent, посылаемые peer service, и посылает ему в ответ
PeerCommand. Также gossip service устанавливает, с какого блока mining service должен майнить,
и получает от него намайненные блоки.

Задачи этого сервиса следующие:
* Обрабатывать новые блоки, полученные от других узлов. Gossip service валидирует блок, и, если
не обнаруживает причин его отвергнуть, форвардит его во все активные сессии с другими узлами,
которые могут не знать про этот блок. Также, если предок нового блока неизвестен, следует
запросить его у узла, от которого пришёл новый блок.
* Обрабатывать запросы на новые блоки. Если в какой-то сессии приходит запрос блока, который
известен данному узлу, gossip service должен послать в этой сессии запрошенный блок.
* Обрабатывать новые транзакции. При получении новой транзакции, если она валидна, gossip service
должен зафорвардить её во все активные сессии с другими узлами, которые могут не знать про эту
транзакцию.
* Запрашивать неизвестные блоки. Раз в некоторое время, определяемое параметром `eager_requests_interval`
в конфиге, gossip service должен проходиться по всем блокам, родитель которых неизвестен, и пытаться
запросить родительский блок у какого-то из подсоединённых узлов.
* Устанавливать, с какого блока и с какими транзакциями mining service должен майнить.
* Обрабатывать новые блоки, полученные от mining service. Следует рассказать всем подсоединённым
узлам о новом блоке.

### 2.3. Mining service

Mining service получает от gossip service информацию о том, какой блок следует майнить, и посылает
в ответ успешно намайненные блоки.

Конфиг mining service состоит из следующих параметров:
* `mining_thread_count` - сколько потоков использовать для майнинга;
* `max_tx_per_block` - сколько максимум транзакций следует пытатсья добавить в блок;
* `public_key` - публичный RSA-ключ, который должен быть issuer'ом блока.

## 3. Реализация

За вас уже написана вся логика работы с блокчейном как структурой данных. А именно:
* В `src/data.rs` находятся определения блока, транзакции, и PeerMessage. У этих структур уже
настроена сериализация и десериализация с помощью serde, а также уже написаны функции подписи и
валидации блоков и транзакций.
* В `src/block_forest.rs` находится структура BlockForest, которая хранит блоки и транзакции.
Основная функция BlockForest - валидация блоков в контексте всего блокчейна и умение определять
текущий "головной" блок - тот блок, с которого следует начинать майнинг. Методы BlockForest:
  * `head()` - вернуть текущий "головной" блок;
  * `unknown_block_hashes()` - вернуть хеши всех блоков, про которые BlockForest сейчас ничего не
  знает, кроме того, что эти блоки являются предками каких-то известных блоков. Именно эти хеши
  надо запрашивать в GossipService с интервалом `eager_requests_interval`;
  * `pending_transactions()` - транзакции, которые ждут добавления в блокчейн. Эти транзакции
  следует использовать при майнинге;
  * `find_block()` - найти блок по хешу;
  * `next_max_hash()` - с каким max_hash следует майнить следующий блок;
  * `add_block()` - попытаться добавить блок в блокчейн. Если валидация этого блока в контексте
  известных блоков будет неуспешной, вызов вернёт ошибку;
  * `add_transaction()` - добавить транзакцию к pending transactions. Если у отправителя недостаточно
  средств, возвращает ошибку.

От вас требуется реализовать лишь логику PeerService, GossipService и MiningService.

### 3.1. Общие советы

1. Вы наверняка захотите запустить несколько async-функций, работающих впараллель, и дождаться
их выполнения. Есть два способа это сделать.
  * Первый способ - запустить как независимые таски:
  ```rust
  async fn foo() { /* ... */ }
  async fn bar() { /* ... */ }

  let foo_handle = tokio::spawn(foo());
  let bar_handle = tokio::spawn(bar());
  // Можно сделать join на handles, или select, или ничего не делать.
  ```
  Tokio будет поллить их независимо друг от друга и от вашей родительской таски. Минус такого
  подхода - если у `foo()` и `bar()` есть общие данные, вам надо их пробрасывать в таски через
  `Arc<Mutex<...>>`.
  * Второй способ - запустить эти функции внутри существующей таски. Этот способ лучше подходит,
  когда `foo` и `bar` являются методами, т.к. вы можете захватить `&self`:
  ```rust
  impl MyType {
      async fn foo(&self) { /* ... */ }
      async fn bar(&self) { /* ... */ }

      async fn run(&mut self) {
          let foo_future = self.foo();
          let bar_future = self.bar();
          tokio::join!(foo_future, bar_future);
      }
  }
  ```
  Поскольку с т.з. tokio создания новых тасок не происходит, вам нужно позаботиться о том, чтобы
  в момент поллинга родительской таски дочерние тоже поллились. Проще говоря, вам обязательно
  нужно как-то использовать `foo_future` и `bar_future` - например, через `join!` или `select!`.

2. Если у вас есть локальная фьюча, которую вы хотите поллить, а также канал, из которого вы
хотите читать в цикле, то можно оба действия совместить в одном `select`. Для этого придётся
запинить фьючу:
```rust
async fn foo() { /* ... */ }

async fn do(receiver: Receiver<...>) {
    let foo_future = foo();
    tokio::pin!(foo_future);

    loop {
        tokio::select! {
            _ = foo_future => {
                info!("foo terminated");
                break;
            }
            value = receiver.recv() => {
                do_stuff(value);
            }
        }
    }
}
```

### 3.2. Советы по PeerService

* Для установления TCP-соединений используйте типы [TcpListener](https://docs.rs/tokio/latest/tokio/net/struct.TcpListener.html)
и [TcpStream](https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html). Они очень похожи на соответствующие типы в std.
* Для прослушивания TCP-порта и установления соединений может быть удобно
иметь отдельные async-методы `listen_loop` и `dial_loop`, где последний пытается установить соединение с конкретным адресом из конфига. Чтобы агрегировать заранее
неизвестное число фьюч `dial_loop` в стрим, используйте [FuturesUnordered](https://docs.rs/futures/latest/futures/stream/struct.FuturesUnordered.html). Пример использования:

```rust
let mut futures = FuturesUnordered::new();
futures.push(dial_loop(address));
while let Some(result) = futures.next().await {
	// ...
}
```

* Для вас уже написан `MessageReader`, который конвертирует `ReadHalf` (получаемый из `TcpStream::split`)
в stream `VerifiedPeerMessage`. Чтобы достать следующий элемент стрима, используйте `.next()`.
* Обработку соединения с каждым отдельным пиром проще иметь в виде независимой таски.
* Для сериализации сообщений используйте `serde_json::to_string()`.

### 3.3. Советы по GossipService

* Для периодических eager-запросов удобно использовать [tokio::time::interval](https://docs.rs/tokio/latest/tokio/time/fn.interval.html).
Заметьте, что значение `eager_requests_interval`, равное 0, нужно интерпретировать как отключение eager requests.
* GissipService - единственный сервис из трёх, который что-то знает про блокчейн
глобально. Это знание вам нужно извлекать через `BlockForest`.

### 3.4. Советы по MiningService

* Майнинг-треды запускайте через привычный `thread::spawn`. Убедитесь, что они не утекают при дропе `MiningService`.
* Для общения с майнинг-тредами используйте синхронный канал из `std::sync::mpsc`.
На стороне `MiningService` чтение из канала осуществляйте с помощью `MiningService::make_block_stream` -
эта функция конвертирует синхронный `Receiver` в асинхронный `Stream`.

## 4. Тестирование

Логи вашего сервиса записываются внутрь папки test_artifacts, где каждому тесту соответствует
своя поддиректория.

В случае провала какого-то теста полный лог этого теста также будет выведен в stderr
после строки "=== BEGIN LOGS OF TEST 'test_name' ===". Это может быть полезно для того,
чтобы дебажить падения, которые плохо воспроизводятся локально.
