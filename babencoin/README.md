В этом проекте мы с вами напишем blockchain, основанный на простом алгоритме proof of work -
Babencoin (все права защищены, любое использование токена без согласия владельце запрещено).

## 1. Описание блокчейна

### 1.1. Формат блока

Блокчейн - это последовательность блоков. Пример блока нашего блокчейна:

```json
{
  "index": 1,
  "nonce": 27532,
  "reward": 1000,
  "issuer": "...",
  "timestamp": 1626003028,
  "max_hash": "...",
  "prev_hash": "...",
  "transactions": [
    {
      "amount": 500,
      "fee": 30,
      "comment": "hi",
      "sender": "...",
      "receiver": "...",
      "signature": "..."
    }
  ]
}
```

(полный блок, без сокращений, можно увидеть в `data/test_block.json`)

Значения полей:
* `index` - расстояние от данного блока до блока генезиса (нулевого блока, захардкоженного в блокчейн);
* `nonce` - произвольное число, не несущее смысла само по себе;
* `reward` - кол-во бабенкоинов, которое получает тот, кто намайнил этот блок;
* `issuer` - публичный RSA-ключ того, кто намайнил этот блок (он же получает `reward`);
* `timestamp` - таймстемп момента, когда этот блок создан;
* `max_hash` - максимально допустимое значение хеша, которым должен обладать этот блок (см. 1.3);
* `prev_hash` - хеш предыдущего блока;
* `transactions` - список транзакций данного блока. Поля транзакции:
  * `amount` - сколько бабенкоинов пересылается;
  * `fee` - сколько бабенкоинов достаётся майнеру блока;
  * `comment` - произвольный строковой комментарий;
  * `sender` - публичный RSA-ключ отправителя средств;
  * `receiver` - публичный RSA-ключ получателя средств;
  * `signature` - подпись транзакции приватным ключом отправителя.

При сериализации в json, подписи, ключи и хеши представляются в кодировке base64.

Мы не будем приводить точную спецификацию того, как считается хеш блока и подпись, а также в каком
именно формате серализуется RSA-ключ. Считайте, что это определено реализацией в `src/data.rs`.

### 1.2. Протокол

Все узлы блокчейна образуют одноранговую (peer-to-peer) сеть - т.е. общение между узлами абсолютно
симметрично (в отличие, например, от клиент-серверных протоколов).

Узлы устанавливают друг с другом соединения по протоколу TCP. По установленному соединению узлы
обмениваются сообщениями в формате json. Каждые два последовательных сообщения разделены нулевым
байтом. Максимальный размер одного сообщения - 64 килобайта.

Бывает три разновидности сообщений:

1. Блок - отправитель сообщает получателю о том, что существует некоторый валидный с т.з.
отправителя блок. Формат:
```json
{
	"kind": "block",
	... // все атрибуты блока в том виде, как они представлены в 1.1.
}
```
2. Транзакция - отправитель сообщает получателю, что существует некоторая валидная с т.з.
отправителя транзакция, ещё не присутствующая ни в каком блоке. Формат:
```json
{
	"kind": "transaction",
	... // все атрибуты транзакции в том виде, как они представлены в 1.1.
}
```
3. Запрос блока - отправитель сообщает получателю, что желает получить блок, хеш которого равен
указанному хешу. Формат:
```json
{
	"kind": "request",
	"block_hash": "..."
}
```
Добросовестно реализованный узел при получении такого сообщения должен проверить, имеется ли у него
информация о таком блоке, и если да, отправить этот блок в ответ сообщением первого типа.

### 1.3. Майнинг

Любой участник сети может добавить в блокчейн новый блок на следующих условиях:

1. Этот блок должен иметь в качестве предка блок генезиса (родство определяется ссылками `prev_hash`);
2. Его `timestamp` должен быть больше, чем `timestamp` родительского блока;
3. `reward` не должен превышать 1000;
4. Все транзакции блока должны быть валидными:
  * Отправитель каждой транзакции должен иметь на счету достаточно бабенкоинов, чтобы оплатить
  `amount + fee`;
  * Транзакция должна иметь верную подпись отправителя.
5. Численное значение хеша блока не должно превышать значение `max_hash`.

Значение max_hash рассчитывается каждые 16 блоков следующим образом:

```
new_max_hash = old_max_hash * (avg_block_mining_time / target_block_mining_time)
```

Здесь:
* `old_max_hash` - значение max_hash на протяжении предыдущих 16 блоков;
* `avg_block_mining_time` - среднее время майнинга одного блока за последние 16 блоков;
* `target_block_mining_time` - 10 секунд.

Задача майнера - подобрать такой `nonce`, чтобы хеш блока не превосходил `max_hash` - тогда
полученный блок будет валидным, другие участники признают этот блок и майнер получит свою награду.

Добросовестно реализованный майнер должен майнить новый блок, `prev_hash` которого равен хешу
блока с максимальным `index` среди всех валидных блоков, которые данному майнеру известны. При
наличии нескольких таких блоков с одинаковым `index`, майнеру следует предпочитать тот блок,
который раньше всех стал известен данному майнеру.

## 2. Архитектура узла

Узел состоит из трёх сервисов, каждый из которых работает в отдельном потоке, общаясь с другими
сервисами посредством каналов.

1. Peer service - управляет TCP-соединениями с другими узлами;
2. Gossip service - распространяет между узлами информацию о блоках и транзакциях;
3. Mining service - майнит новый блок.

Схема взаимосвязей между сервисами:

```
        TCP streams
             ▲
             │
             ▼
     ┌────────────────┐
     │                │
     │  Peer service  │
     │                │
     └─────┬──────────┘
           │   ▲
 PeerEvent │   │ PeerCommand
           ▼   │
     ┌─────────┴──────┐
     │                │
     │ Gossip service │
     │                │
     └─────┬──────────┘
           │   ▲
MiningInfo │   │ Block
           ▼   │
     ┌─────────┴──────┐
     │                │
     │ Mining service │
     │                │
     └────────────────┘
```


### 2.1. Peer service

Peer service генерирует события PeerEvent и реагирует на команды PeerCommand.

События всегда происходят в рамках какой-то сессии, где сессия означает TCP-соединение. Каждому
новому соединению назначается новый уникальный целочисленный идентификатор сессии.

События бывают трёх типов:
1. Создана новая сессия (к нам подсоединились, либо мы успешно установили соединение);
2. Пришло новое сообщение;
3. Сессия разорвана.

Команды, на которые реагирует peer service, бывают двух типов:
1. Послать какое-то сообщение в рамках конкретной сессии;
2. Разорвать сессию.

Конфиг peer service состоит из следующих параметров:
* `dial_addresses` - список адресов, с которыми сервис будет активно пытаться установить соединение;
* `dial_cooldown` - сколько времени подождать после неудачной попытки соединения или его разрыва
перед тем, как пытаться снова соединиться с адресом;
* `listen_address` - на каком адресе слушать входящие соединения.

### 2.2. Gossip service

Gossip service реагирует на события PeerEvent, посылаемые peer service, и посылает ему в ответ
PeerCommand. Также gossip service устанавливает, с какого блока mining service должен майнить,
и получает от него намайненные блоки.

Задачи этого сервиса следующие:
* Обрабатывать новые блоки, полученные от других узлов. Gossip service валидирует блок, и, если
не обнаруживает причин его отвергнуть, форвардит его во все активные сессии с другими узлами,
которые могут не знать про этот блок. Также, если предок нового блока неизвестен, следует
запросить его у узла, от которого пришёл новый блок.
* Обрабатывать запросы на новые блоки. Если в какой-то сессии приходит запрос блока, который
известен данному узлу, gossip service должен послать в этой сессии запрошенный блок.
* Обрабатывать новые транзакции. При получении новой транзакции, если она валидна, gossip service
должен зафорвардить её во все активные сессии с другими узлами, которые могут не знать про эту
транзакцию.
* Запрашивать неизвестные блоки. Раз в некоторое время, определяемое параметром `eager_requests_interval`
в конфиге, gossip service должен проходиться по всем блокам, родитель которых неизвестен, и пытаться
запросить родительский блок у какого-то из подсоединённых узлов.
* Устанавливать, с какого блока и с какими транзакциями mining service должен майнить.
* Обрабатывать новые блоки, полученные от mining service. Следует рассказать всем подсоединённым
узлам о новом блоке.

### 2.3. Mining service

Mining service получает от gossip service информацию о том, какой блок следует майнить, и посылает
в ответ успешно намайненные блоки.

Конфиг mining service состоит из следующих параметров:
* `thread_count` - сколько потоков использовать для майнинга;
* `max_tx_per_block` - сколько максимум транзакций следует пытатсья добавить в блок;
* `public_key` - публичный RSA-ключ, который должен быть issuer'ом блока.

## 3. Реализация

За вас уже написана вся логика работы с блокчейном как структурой данных. А именно:
* В `src/data.rs` находятся определения блока, транзакции, и PeerMessage. У этих структур уже
настроена сериализация и десериализация с помощью serde, а также уже написаны функции подписи и
валидации блоков и транзакций.
* В `src/block_forest.rs` находится структура BlockForest, которая хранит блоки и транзакции.
Основная функция BlockForest - валидация блоков в контексте всего блокчейна и умение определять
текущий "головной" блок - тот блок, с которого следует начинать майнинг. Методы BlockForest:
  * `head()` - вернуть текущий "головной" блок;
  * `unknown_block_hashes()` - вернуть хеши всех блоков, про которые BlockForest сейчас ничего не
  знает, кроме того, что эти блоки являются предками каких-то известных блоков. Именно эти хеши
  надо запрашивать в GossipService с интервалом `eager_requests_interval`;
  * `pending_transactions()` - транзакции, которые ждут добавления в блокчейн. Эти транзакции
  следует использовать при майнинге;
  * `find_block()` - найти блок по хешу;
  * `next_max_hash()` - с каким max_hash следует майнить следующий блок;
  * `add_block()` - попытаться добавить блок в блокчейн. Если валидация этого блока в контексте
  известных блоков будет неуспешной, вызов вернёт ошибку;
  * `add_transaction()` - добавить транзакцию к pending transactions. Если у отправителя недостаточно
  средств, возвращает ошибку.

От вас требуется реализовать лишь логику PeerService, GossipService и MiningService.

Советы:
* В PeerService вам, скорее всего, понадобится по два потока на каждое TCP-соединение: один поток
обслуживает чтения, другой - записи;
* Для сериализации/десериализации сообщений используйте `serde_json::from_str()` и `serde_json::to_writer()`;
* В GossipService используйте макрос `select!()`, чтобы читать одновременно из нескольких каналов
crossbeam.

## 4. Тестирование

Логи вашего сервиса записываются внутрь папки test_artifacts, где каждому тесту соответствует
своя поддиректория.

В случае провала какого-то теста полный лог этого теста также будет выведен в stderr
после строки "=== BEGIN LOGS OF TEST 'test_name' ===". Это может быть полезно для того,
чтобы дебажить падения, которые плохо воспроизводятся локально.