В данном проекте мы предлагаем вам реализовать декомпрессор файлов формата gzip.

## Описание формата

Файл `.gz` представляет собой последовательность блоков данных, каждый из которых сжат (обычно) алгоритмом deflate.
Спефицикация gzip и deflate содержится в следующих RFC:

* [RFC1951 DEFLATE Compressed Data Format Specification](https://datatracker.ietf.org/doc/html/rfc1951)
* [RFC1952 GZIP file format specification](https://datatracker.ietf.org/doc/html/rfc1952)

Ниже представлена краткая спецификация этих форматов. В случае любых неоднозначностей источником правды
являются приведённые выше RFC.

### 1. Формат GZIP

Файл формата gzip представляет собой последовательность прозвольного количества members.
Каждый member имеет следующий формат (`+---+` обозначает 1 байт):

```
+---+---+---+---+---+---+---+---+---+---+
|ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (ещё-->)
+---+---+---+---+---+---+---+---+---+---+
```

(если установлен FLG.FEXTRA)

```
+---+---+============================+
| XLEN  |...XLEN байт "доп. полей"...| (ещё-->)
+---+---+============================+
```

(если установлен FLG.FNAME)

```
+=============================================+
|...оригинальное имя файла, zero-terminated...| (ещё-->)
+=============================================+
```

(если установлен FLG.FCOMMENT)

```
+==================================+
|...комментарий, zero-terminated...| (ещё-->)
+==================================+
```

(если установлен FLG.FHCRC)

```
+---+---+
| CRC16 |
+---+---+
```

```
+===================+
|...сжатые данные...| (ещё-->)
+===================+

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|     CRC32     |     ISIZE     |
+---+---+---+---+---+---+---+---+
```

Расшифровка полей:
* ID1, ID2 - идентификаторы формата gzip, должны быть равны 0x1f и 0x8b соответственно.
* CM (Compression Method) - алгоритм сжатия. CM = 8 означает "deflate", значения с 0 до 7 зарезервированы.
* FLG (флаги) - от младшего бита к старшему:

  0. FTEXT - обозначает, что оригинальный файл является текстом в ASCII.
  1. FHCRC - обозначает присутствие контрольной суммы заголовка (CRC16).
  2. FEXTRA - обозначает присутствие дополнительных полей (не определяются стандартом).
  3. FNAME - обозначает присутствие имени оригинального файла.
  4. FCOMMENT - обозначает присутствие комментария.

  Остальные биты зарезервированы и должны быть равны 0.

* MTIME - timestamp последней модификации оригинального файла.
* XFL - дополнительные флаги, специфичные для алгоритма сжатия.
* OS - идентифицирует операционную систему.
* XLEN - если флаг FEXTRA выставлен, даёт длину "дополнительных полей".
* CRC32 - контрольная сумма оригинального файла, рассчитанная по алгоритму CRC-32 (ISO 3309).
* ISIZE - размер оригинального файла по модулю 2^32.

### 2. Формат DEFLATE

#### 2.1. Формат блока

Данные в формате deflate представляют собой последовательность блоков. Каждый блок начинается
с заголовка длиной в 3 бита:

1. Бит BFINAL - является ли данный блок последним
2. Биты BTYPE (2 шт) - тип блока. Определяет, каким образом сжаты данные:
  * 00 - данные не сжаты.
  * 01 - данные сжаты фиксированным кодом Хаффмана.
  * 10 - данные сжаты динамическим кодом Хаффмана.
  * 11 - зарезервировано.

В данной задаче вам достаточно поддержать BTYPE=00 и BTYPE=10.

Если BTYPE=00:
1. Отбросьте все непрочитанные биты в текущем байте.
2. Прочитайте LEN (2 байта) и NLEN (2 байта).
3. Проверьте, что LEN == !NLEN.
4. Прочитайте LEN байт данных. Это несжатые данные исходного файла.

Если BTYPE=10, см. далее.

#### 2.2. Сжатые блоки

Общая идея алгоритма deflate в том, что, если в данных много повторяющихся подпоследовательностей,
то можно такие подпоследовательности заменить на отсылки к прошлым данным.

Сжатые блоки представляют собой последовательность токенов, каждый из которых принадлежит одному
из трёх алфавитов:

* Литеральные токены - кодируют один байт исходного файла, либо конец блока.
* Токены длины
* Токены расстояния

Литеральные токены и токены длины кодируются одним и тем же алфавитом (назовём его litlen).
Общий алгоритм чтения сжатого блока следующий:

1. Прочитать токен из алфавита litlen.
2. Если был прочитан токен конца блока - конец (перейти к чтению следующего блока deflate).
3. Если был прочитан литеральный токен, то записать на вывод соответствующий байт. Go to п.1.
4. Если был прочитан токен длины `l`, то:
  * Прочитать токен расстояния `d`
  * Записать на выход последовательность байт (исходного файла) длины `l`, начавшуюся `d` байт назад.
  * Go to п.1.

Заметьте, что `l` может быть больше `d`. Это значит, что надо повторять последовательность зациклено,
пока не наберётся `l` байт.

Алфавит litlen представлен токенами с номерами от 0 до 285. Токены от 0 до 255 являются литеральными -
т.е. они кодируют соответствующий байт оригинального файла. Токен 256 кодирует конец блока. Токены
от 257 до 285 являются токенами длины. Каждый токен длины кодирует базовую длину, а также то, сколько
бит необходимо прочитать далее, чтобы прибавить значение этих бит к базовой длине и получить финальную
длину. Соответствие между токеном длины, базовой длиной и кол-вом дополнительных бит следующее:

```
     Extra               Extra               Extra
Code Bits Length(s) Code Bits Lengths   Code Bits Length(s)
---- ---- ------     ---- ---- -------   ---- ---- -------
 257   0     3       267   1   15,16     277   4   67-82
 258   0     4       268   1   17,18     278   4   83-98
 259   0     5       269   2   19-22     279   4   99-114
 260   0     6       270   2   23-26     280   4  115-130
 261   0     7       271   2   27-30     281   5  131-162
 262   0     8       272   2   31-34     282   5  163-194
 263   0     9       273   3   35-42     283   5  195-226
 264   0    10       274   3   43-50     284   5  227-257
 265   1  11,12      275   3   51-58     285   0    258
 266   1  13,14      276   3   59-66
```

Алфавит токенов расстояний состоит из 30 токенов, с таким же принципом кодирования значений, как и
у токенов длины:

```
     Extra           Extra               Extra
Code Bits Dist  Code Bits   Dist     Code Bits Distance
---- ---- ----  ---- ----  ------    ---- ---- --------
  0   0    1     10   4     33-48    20    9   1025-1536
  1   0    2     11   4     49-64    21    9   1537-2048
  2   0    3     12   5     65-96    22   10   2049-3072
  3   0    4     13   5     97-128   23   10   3073-4096
  4   1   5,6    14   6    129-192   24   11   4097-6144
  5   1   7,8    15   6    193-256   25   11   6145-8192
  6   2   9-12   16   7    257-384   26   12  8193-12288
  7   2  13-16   17   7    385-512   27   12 12289-16384
  8   3  17-24   18   8    513-768   28   13 16385-24576
  9   3  25-32   19   8   769-1024   29   13 24577-32768
```

#### 2.3. Код Хаффмана

Токены litlen, а также токены расстояний кодируются по алгоритму Хаффмана.

Код Хаффмана является префиксным бинарным кодом - это значит, что он кодирует символы заранее
известного алфавита последовательностями бит разной длины, таким образом, что последовательность
символов может быть однозначно раскодирована символ за символом.

Чтобы раскодировать последовательность бит в последовательность символов, нужно знать, какую
последовательность бит кодировщик назначил каждому символу. Чтобы декодер мог восстановить эту
информацию, кодировщику достаточно записать длину кода каждого символа. Зная длины кодов всех символов,
декодер может восстановить соответствие "символ <-> последовательность бит" и провести декодирование.

Алгоритм восстановления соответствия между символами и битовыми последовательностями приведён ниже.
Для каждого символа, длина кода которого равна `symbol[i].Len`, этот алгоритм запишет его код в `symbol[i].Code`
как целое число. Чтобы интерпретировать это число как битовую последовательность, надо читать его
побитово начиная со **старшего** бита (начиная с бита номер `symbol[i].Len`).

1. Сосчитать кол-во кодов каждой длины.	Пусть `bl_count[N]` равно числу кодов длины N, N >= 1.
2. Найти численное значение наименьшего кода каждой длины (MAX_BITS = 15):

    ```c
    code = 0;
    bl_count[0] = 0;
    for (bits = 1; bits <= MAX_BITS; bits++) {
        code = (code + bl_count[bits-1]) << 1;
        next_code[bits] = code;
    }
    ```

3. Проставить значения кодов всех символов:

    ```c
    for (n = 0; n <= max_code; n++) {
        len = symbol[n].Len;
        if (len != 0) {
            symbol[n].Code = next_code[len];
            next_code[len]++;
        }
    }
    ```

В RFC1951 приведён пример восстановления битовых кодов (секция 3.2.2).

#### 2.4. Динамический код Хаффмана (BTYPE=10)

При BTYPE=10 кодировщик в начале блока данных записывает информацию и том, какие последовательности
бит он поставил в соответствие токенам litlen и какие токенам расстояний (это два разных кода).
В первом приближении, каждая кодировка представлена последовательностью длин кодов каждого токена.
Из длин кодов можно восстановить кодировку, как показано в пункте 2.3.

Однако, чтобы сжатие было ещё эффективнее, даже представления кодов Хаффмана закодированы кодом
Хаффмана. Алфавит, кодирующий длины кодов, состоит из 19 токенов:

* 0-15: обозачает длину кода от 0 до 15 бит.
* 16: копировать предыдущую длину 3-6 раз. Следующие 2 бита обозначают точное кол-во раз.
* 17: повторить нулевую длину кода 3-10 раз. Следующие 3 бита обозначают точное кол-во раз.
* 18: повторить нулевую длину кода 11-138 раз. Следующие 7 бит обозначают точное кол-во раз.

Нулевая длина кода означает, что соответствующий символ в алфавите litlen или алфавите расстояний
не используется.

Теперь мы можем определить формат сжатого блока:

* 5 бит: HLIT - кол-во кодов litlen минус 257 (т.е. от 257 до 286)
* 5 бит: HDIST - кол-во кодов расстояний минус 1 (т.е. от 1 до 32)
* 4 бита: HCLEN - кол-во кодов длины кода минус 4 (т.е. от 4 до 19)
* (HCLEN + 4) x 3 бит: длины кодов алфавита длин кодов, приведённого выше в п. 2.4., в следующем
порядке: 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15. Эти коды представлены
трёхбитовыми целыми числами (0-7). Нулевая длина кода означает, что соответствующий символ алфавита
не используется.
* HLIT + 257 длин кодов алфавита litlen, закодированных с помощью кода длин.
* HDIST + 1 длин кодов алфавита расстояний, закодированных с помощью кода длин.

  Если в алфавите расстояний используется всего один символ, то он кодируется единичным битом,
  а не нулевым (как следовало бы из алгоритма в п. 2.3).

* Сжатые данные блока.
* Символ конца блока (256 в алфавите litlen).

## Реализация

Вам необходимо реализовать фукнцию decompress в `src/lib.rs`.

Для вашего удобства в коде уже выделен ряд абстракций, которыми вы можете воспользоваться, и даже
написаны тесты на некоторые из них. Однако вы вольны менять уже написанный код и тесты на него
произвольным образом. Единственное требование для успешной сдачи задания - проходящая тесты
реализация `decompress`.

### Выделенные абстракции

* GzipReader - читает заголовок и footer формата gzip.
* DeflateReader - читает заголовок формата deflate.
* HuffmanCoding - декодер токенов, закодированных алгоритмом Хаффмана. Параметризуется типом токена:
  * TreeCodeToken - кодирует длины кодов Хаффмана (см. п. 2.4)
  * LitLenToken - кодирует литерал, длину или конец блока (см. п. 2.2)
  * DistanceToken - кодирует расстояние (см. п. 2.2)
* BitReader - реализует побитовое чтение потока.
* TrackingWriter - писатель с памятью в 32 килобайта, отслеживающий количество записанных байт и
поддерживающий их контрольную сумму CRC32.

### Порядок реализации

Мы рекомендуем реализовывать указанные абстракции "снизу вверх". А именно:

1. BitReader. Убедитесь, что его тесты проходят, командой `cargo test bit_reader`.
2. TrackingWriter - `cargo test tracking_writer`.
3. HuffmanCoding - `cargo test huffman_coding`.
4. GzipReader, DeflateReader. На них нет отдельных тестов.
5. decompress.

### Обработка ошибок

Для обработки ошибок используется библиотека anyhow. Не стесняйтесь пользоваться
оператором `?`, `.with_context` и `bail!`.

Тесты ожидают, что сообщение об ошибке содержит конкретную подстроку, в следующих случаях:

* Кол-во байт в gzip footer не соответствует действительности: "length check failed"
* Контрольая сумма данных не сходится с указанной в gzip footer: "crc32 check failed"
* Неверные значения первых двух байт в заголовке gzip: "wrong id values"
* Неверное значение контрольной суммы заголовка gzip: "header crc16 check failed"
* Неизвестный тип блока в заголовке gzip: "unsupported block type"
* Неизвестный compression method в заголовке deflate: "unsupported compression method"
* В блоке BTYPE = 00 нарушается LEN == !NLEN: "nlen check failed"

### Советы

* Для логирования используйте макросы `error!`, `warn!`, `info!`, `debug!` и `trace!`,
импортируемые из библиотеки `log`. По-умолчанию ripgzip логирует только errors и
warnings. Для увеличения уровня логирования используйте ключи `-v`, `-vv` и `-vvv`.
* Для чтения полей заголовков используйте `.read_u8()`, `.read_u32::<LittleEndian>()`
и т.д. Эти методы реализованы трейтом `ReadBytesExt` билиотеки `byteorder`.
* Для подсчёта crc32 используйте `crc32::Digest` типа `crc32::IEEE` из библиотеки `crc`.
