В этой задаче вам предлагается добавить поддержку UDP-сокетов в асинхронный рантайм.

## 1. mio

Всё бремя взаимодействия с ОС на себя берёт библиотека mio. Она предоставляет кросс-платформенное API для неблокирующей работы с I/O. На Linux mio - тонкая обёртка над системным вызовом `epoll`.

В mio даже есть готовый тип `UdpSocket`, над которым можно проворачивать неблокирующие операции ввода-вывода. Пример базового использования `UdpSocket` (взят из документации):

```rust
// Программа Echo:
// SENDER - посылает сообщение.
// ECHOER - распечатывает входящие сообщения.

use mio::net::UdpSocket;
use mio::{Events, Interest, Poll, Token};
use std::time::Duration;

// Токен - это идентификатор сокета, с которым связывается событие
// доступности на чтение/запись.
const SENDER: Token = Token(0);
const ECHOER: Token = Token(1);

// Создаём сокеты на разных портах.
let mut sender_socket = UdpSocket::bind("127.0.0.1:0".parse()?)?;
let mut echoer_socket = UdpSocket::bind("127.0.0.1:0".parse()?)?;

// Сахар: connect просто избавляет нас от необходиомсти указывать
// каждый раз адрес, куда надо отправить сообщение.
sender_socket.connect(echoer_socket.local_addr()?)?;

// Создаём новый Poll - это объект, через который доставляются события.
let mut poll = Poll::new()?;

// Регистрируем сокеты, чтобы Poll возвращал связанные с ними события.
poll.registry().register(&mut sender_socket, SENDER, Interest::WRITABLE)?;
poll.registry().register(&mut echoer_socket, ECHOER, Interest::READABLE)?;

let msg_to_send = [9; 9];
let mut buffer = [0; 9];

let mut events = Events::with_capacity(128);
loop {
	// .poll() заблокируется до тех пор, пока не появятся новые события,
	// или пока не пройдёт 100 миллисекунд.
    poll.poll(&mut events, Some(Duration::from_millis(100)))?;
    for event in events.iter() {
        match event.token() {
            // Можно писать данные в SENDER.
			// Гарантируется, что после регистрации сокета event
			// доступности на запись обязательно вернётся из poll.
            SENDER => {
                let bytes_sent = sender_socket.send(&msg_to_send)?;
                assert_eq!(bytes_sent, 9);
                println!("sent {:?} -> {:?} bytes", msg_to_send, bytes_sent);
            },
            // Появились доступные для чтения данные.
            ECHOER => {
                let num_recv = echoer_socket.recv(&mut buffer)?;
                println!("echo {:?} -> {:?}", buffer, num_recv);
                buffer = [0; 9];
            }
            _ => unreachable!()
        }
    }
}
```

Если на mio::UdpSocket позвать операцию, которая может привести к блокировке (например, вызвать `.recv()`, когда данных ещё нет), то вернётся `io::Error` с `ErrorKind::WouldBlock`.

`mio::Poll` работает в т.н. edge-triggered режиме. Это значит, что, когда сокет станет готов на чтение, событие об этом придёт ровно один раз. Пока сокет содержит непрочитанные данные, все последующие вызовы `Poll::poll` не будут возвращать это событие снова. Сперва вы должны вычитать все данные из сокета, получить `ErrorKind::WouldBlock`, и только после этого `Poll::poll` оповестит вас о новых данных. Аналогично работает оповещение о событиях записи (у `mio::Event` есть методы `is_readable` и `is_writable` - заметьте, что могут быть выставлены оба флага, если сокет стал одновременно готов на чтение и на запись).

У `mio::UdpSocket` много методов, но в рамках задачи вам предлагается написать асинхронные обёртки только для небольшого их числа:
* bind
* connect
* local_addr
* recv
* recv_from
* send
* send_to

## 2. Склейка mio с рантаймом

Весь связанный с сетью код находится в файле `src/network.rs`.

Поддержка UDP-сокетов в рантайме состоит из двух частей:
* Обёртка над `mio::UdpSocket`, которая умеет подписываться на события готовности к чтению/записи
* Отдельный тред, который обрабатывает приходящие от `Poll` события - в частности, пробуждает фьючи, которые этих событий ожидают.

Рантайм запускает сетевую подсистему вызовом `NetworkDriver::start()`. Вызов создаёт `NetworkDriver` со всем необходимым состоянием и запускает цикл обработки событий в отдельном потоке. Этот вызов возвращает `NetworkHandle`, который впредь будет доступен из контекста рантайма как `RuntimeHandle::current().state().network_handle` (но только коду рантайма - это непубличное API). Когда рантайм будет уничтожен, позовётся деструктор `NetworkHandle`, который должен остановить связанный поток.

Жизненный цикл `UdpSocket` состоит из трёх фаз:
1. Создание сокета - в этот момент сокет должен подписаться на `read` и `write` события нижележащего `mio::UdpSocket` (т.к. мы заранее не знаем, что будет делать пользователь - только читать, только писать или всё вместе). За это отвечает метод `Registry::register`.
2. Обработка асинхронной операции чтения (записи) - надо проверить, приходил ли сигнал от `Poll`, что сокет готов к чтению (записи). Если приходил, можно попробовать операцию чтения (записи); если операция возвращает `ErrorKind::WouldBlock` - надо запомнить, что до получения нового сигнала от `Poll` этот сокет не надо читать (писать). Важно убедиться, что у вас нет гонки между операциями над сокетом и нотификациями от `Poll`.
3. Уничтожение сокета - надо отписать `Poll` от событий этого сокета, позвав `Registry::deregister`.

## 3. Советы по реализации

* Чтобы генерировать токены для `mio`, воспользуйтесь `AtomicUsize`. Бывают другие схемы, но эта самая простая и кросс-платформенная.
* Внутри `UdpSocket` стоит завести отдельный метод `async_io`, принимающий `impl FnMut() -> io::Result<T>`. Этот метод подписывается на готовность сокета и пытается провести указанную операцию до тех пор, пока она не вернёт что-то отличное от `ErrorKind::WouldBlock`.
* Внутри сокета вам придётся сохранить `RuntimeHandle` - ведь сокет может переходить между тредами, а значит, между рантаймами.
* По контракту `Future`, в момент готовности фьючи рантайм должен позвать waker, переданный в **последний** вызов `Future::poll`.
* Не предполагается, что в этой задаче вы напишете оптимальное по производительности решение. Самая простая реализация может держать всё состояние всех сокетов под одним мьютексом, и брать его в методах `UdpSocket` и в цикле `NetworkDriver`. Мы настоятельно рекомендуем написать именно такое решение, если только вы не чувствуете себя матёрым разработчиком конкурентных алгоритмов :)
* Для отладки можете на своё усмотрене использовать `logging` либо `tracing`. Запустить конкретный тест и посмотреть логи можно следующими командами:
  - Для `logging`: `RUST_LOG=debug cargo test test_name -- --nocapture`
  - Для `tracing`: `RUST_LOG_SPAN_EVENTS=full cargo test test_name -- --nocapture`
