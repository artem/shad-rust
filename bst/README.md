В данной задаче вам предлагается написать наивное бинарное дерево поиска,
поддерживающее вставку, удаление и поиск элемента.

В качестве стратегии вставки предлагается использовать наивную вставку (спускаемся
по дереву, пока оно не закончится, и добавляем элемент на позицию, куда мы пришли).
В качестве стратегии удаления можете реализовать либо удаление с использованием
томбстоунов, либо удаление вращением. Никаких требований к сбалансированности дерева
по итогу вставки и удаления не предъявляется.

## Реализация

Реализуйте методы структуры `BstSet` в файле `src/lib.rs`. В данном файле уже содержится
определение структуры `Node`, которая представляет собой внутренний узел дерева.

Указатели на дочерние узлы представлены типом `Option<Box<Node>>`, где Box - владеющий указатель на данные, лежащие на куче. `Box<T>` не является nullable. Таким образом, `Option<Box<T>>` в Rust является семантическим эквивалентом `std::unique_ptr<T>` в C++.

Советы:
* В реализации метода `contains` заведите мутабельную переменную типа
`&Option<Box<Node>>`, и в процессе спуска по дереву обновляйте её.
* Забегая вперёд, скажем, что красивое сравнение ключей можно осуществить так:

	```rust
	match node.key.cmp(&key) {
		Ordering::Equal => { /* ... */ }
		Ordering::Less => { /* ... */ }
		Ordering::Greater => { /* ... */ }
	}
	```

* В функциях `insert` и `remove` будет нелишне вынести поиск узла бинарного дерева
в отдельный хелпер, который возвращает `&mut Option<Box<Node>>`. Вопрос на понимание:
почему нельзя использовать этот хелпер в `contains`?

## Бенчмарк

В `cbst/src/cbst.c` находится референсная реализация наивного бинарного дерева поиска на
С. Из любопытства можете побенчмаркать свою реализацию относительно реализации на С
командой `make bench`. Авторское решение показывает такие результаты:

```
100k_random_insertions/rust_BstSet
                        time:   [24.933 ms 25.126 ms 25.349 ms]
                        change: [-0.6299% +0.3415% +1.3491%] (p = 0.51 > 0.05)
                        No change in performance detected.
100k_random_insertions/c_BstSet
                        time:   [21.257 ms 21.405 ms 21.588 ms]
                        change: [-0.7640% +0.1810% +1.1501%] (p = 0.74 > 0.05)
                        No change in performance detected.

100k_random_lookup_hits/rust_BstSet
                        time:   [17.959 ms 18.117 ms 18.303 ms]
                        change: [-4.2873% -3.0002% -1.6136%] (p = 0.00 < 0.05)
                        Performance has improved.
100k_random_lookup_hits/c_BstSet
                        time:   [12.495 ms 12.625 ms 12.782 ms]
                        change: [-9.8411% -6.1549% -2.8859%] (p = 0.00 < 0.05)
                        Performance has improved.

100k_random_lookup_misses/rust_BstSet
                        time:   [22.585 ms 22.858 ms 23.178 ms]
                        change: [-3.3942% -1.2532% +0.9146%] (p = 0.27 > 0.05)
                        No change in performance detected.
100k_random_lookup_misses/c_BstSet
                        time:   [18.544 ms 18.791 ms 19.106 ms]
                        change: [-2.6945% -1.0312% +0.7947%] (p = 0.27 > 0.05)
                        No change in performance detected.
```

Видно, что реализация на Rust немного медленнее - скорее всего, за счёт того, что
`Option::unwrap()` осуществляет проверку на null. Чтобы честно побить С в таком
назкоуровневом коде, нужно спускаться до использования unsafe, но на идиоматичном
Rust производительность получается не сильно хуже.